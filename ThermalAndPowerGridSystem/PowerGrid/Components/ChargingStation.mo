within ThermalAndPowerGridSystem.PowerGrid.Components;

model ChargingStation

  extends Icons.ChargingStation_Icon;
  
  import SI = Modelica.Units.SI;
  import nSI = Modelica.Units.NonSI;
  
  SI.Power totalBikePowerDemand, totalCarPowerDemand;
  
  parameter Integer randomIDforBike = 30020;
  parameter Integer randomIDforCar = 30021;
  parameter Integer idForBike = Modelica.Math.Random.Utilities.initializeImpureRandom(randomIDforBike);
  parameter Integer idForCar = Modelica.Math.Random.Utilities.initializeImpureRandom(randomIDforCar);
  //  Integer randomIDforBike = 30020;
  //  Integer randomIDforCar = 30021;
  //  Integer idForBike = Modelica.Math.Random.Utilities.initializeImpureRandom(randomIDforBike);
  //  Integer idForCar = Modelica.Math.Random.Utilities.initializeImpureRandom(randomIDforCar);
  parameter nSI.Energy_Wh evCarCapacity = 60e3;
  parameter SI.Power evCarChargingRating = 11e3;
  parameter nSI.Energy_Wh evBikeCapacity = 4200;
  parameter SI.Power evBikeChargingRating = 1e2;     
  parameter Integer maxNumberOfBikePerChargingStation = 20;
  parameter Integer maxNumberOfCarPerChargingStation = 12;  
  parameter Integer minNumberOfBikePerChargingStation = 0;
  parameter Integer minNumberOfCarPerChargingStation = 0;
  parameter Integer numberOfChargingStation = 4;
  parameter Real bikeChargingDuration(unit = "Hour") = 3;
  parameter Real carChargingDuration(unit = "Hour") = 6;
  
  Integer numberofEVBikePerChargingStation;
  Integer numberofEVCarPerChargingStation;

  ThermalAndPowerGridSystem.PowerGrid.Interfaces.ElectricalPort electricalPort annotation(
    Placement(visible = true, transformation(origin = {-54, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0), iconTransformation(origin = {-110, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));

algorithm

  when initial() then
     numberofEVBikePerChargingStation := minNumberOfBikePerChargingStation;
  elsewhen sample(0,3600*bikeChargingDuration) then
     numberofEVBikePerChargingStation := Modelica.Math.Random.Utilities.impureRandomInteger(
          id=idForBike,
          imin=minNumberOfBikePerChargingStation,
          imax=maxNumberOfBikePerChargingStation);  
  end when;
  
  when initial() then
    numberofEVCarPerChargingStation := minNumberOfCarPerChargingStation;
  elsewhen sample(0,3600*carChargingDuration) then
    numberofEVCarPerChargingStation := Modelica.Math.Random.Utilities.impureRandomInteger(
          id=idForCar,
          imin=minNumberOfCarPerChargingStation,
          imax=maxNumberOfCarPerChargingStation);  
  end when;
  
equation

  totalBikePowerDemand = numberOfChargingStation * evBikeChargingRating * numberofEVBikePerChargingStation;  
  totalCarPowerDemand = numberOfChargingStation * evCarChargingRating * numberofEVCarPerChargingStation;  
  electricalPort.P = -(totalBikePowerDemand + totalCarPowerDemand);

annotation(
    Diagram,
    Icon(graphics = {Text(origin = {0, -120}, extent = {{-100, 10}, {100, -10}}, textString = "%name", fontSize = 10)}),
  Documentation(info = "<html><head></head><body><!--StartFragment--><span style=\"font-size: 12px; font-family: 'DejaVu Sans Mono';\">This component is model of charging station, which act as demand generated by electric vehicles.</span><div><span style=\"font-family: 'DejaVu Sans Mono'; font-size: 12px;\"><br></span></div><div><span style=\"font-family: 'DejaVu Sans Mono'; font-size: 12px;\">Currently random number of bikes and cars has been generated to demand calculation, it can be further improved by using combi table to import data from text file.</span></div><!--EndFragment--></body></html>"));
end ChargingStation;
